const Applet = imports.ui.applet;
const PopupMenu = imports.ui.popupMenu;
const Mainloop = imports.mainloop;
const GLib = imports.gi.GLib;

function readText(path) {
  try {
    let [ok, bytes] = GLib.file_get_contents(path);
    if (!ok) return null;
    return String(bytes).trim();
  } catch (e) {
    return null;
  }
}

function getDefaultIface() {
  // /proc/net/route: Iface  Destination  Gateway ...
  // Default route: Destination == 00000000
  let txt = readText("/proc/net/route");
  if (!txt) return "enp0s31f6";
  let lines = txt.split("\n");
  for (let i = 1; i < lines.length; i++) {
    let cols = lines[i].trim().split(/\s+/);
    if (cols.length < 2) continue;
    if (cols[1] === "00000000") return cols[0];
  }
  return "enp0s31f6";
}

function readIfaceBytes(iface) {
  let rx = readText(`/sys/class/net/${iface}/statistics/rx_bytes`);
  let tx = readText(`/sys/class/net/${iface}/statistics/tx_bytes`);
  if (rx === null || tx === null) return null;
  let rxn = Number(rx);
  let txn = Number(tx);
  if (!Number.isFinite(rxn) || !Number.isFinite(txn)) return null;
  return { rx: rxn, tx: txn };
}

function fmtBitsPerSec(bps) {
  // show as Mbit/s with 2 decimals (DU-Meter-ish)
  let mbit = (bps * 8) / 1e6;
  if (mbit >= 100) return `${mbit.toFixed(0)} Mbit/s`;
  if (mbit >= 10)  return `${mbit.toFixed(1)} Mbit/s`;
  return `${mbit.toFixed(2)} Mbit/s`;
}

function fmtBytes(bytes) {
  const units = ["B","KB","MB","GB","TB","PB"];
  let v = bytes;
  let u = 0;
  while (v >= 1024 && u < units.length - 1) { v /= 1024; u++; }
  return `${v.toFixed(v >= 10 || u === 0 ? 0 : 2)} ${units[u]}`;
}

class NetStopwatch extends Applet.TextIconApplet {
  constructor(metadata, orientation, panelHeight, instanceId) {
    super(orientation, panelHeight, instanceId);

    this.iface = getDefaultIface();
    this.cacheFile = GLib.build_filenamev([GLib.get_user_cache_dir(), "netstopwatch@store2.json"]);

    this.menuManager = new PopupMenu.PopupMenuManager(this);
    this.menu = new Applet.AppletPopupMenu(this, orientation);
    this.menuManager.addMenu(this.menu);

    this._applet_context_menu.addAction(`Reset Session (${this.iface})`, () => this.resetSession());
    this._applet_context_menu.addAction(`Interface neu erkennen`, () => this.reDetectIface());

    this.set_applet_icon_symbolic_name("network-transmit-receive-symbolic");
    this.set_applet_tooltip("Net Traffic Stopwatch");

    this.last = null;
    this.lastTs = null;

    this.base = null;        // {rx,tx} at reset
    this.baseEpoch = null;   // reset time

    this.loadState();
    if (!this.base) this.resetSession(true);

    this._timer = Mainloop.timeout_add_seconds(1, () => this.tick());
    this.tick();
  }

  on_applet_clicked() {
    this.menu.removeAll();
    let now = GLib.DateTime.new_now_local();
    let baseStr = this.baseEpoch ? GLib.DateTime.new_from_unix_local(this.baseEpoch).format("%Y-%m-%d %H:%M:%S") : "n/a";

    let cur = readIfaceBytes(this.iface);
    if (!cur || !this.base) {
      this.menu.addMenuItem(new PopupMenu.PopupMenuItem(`Interface ${this.iface} nicht lesbar.`));
      this.menu.toggle();
      return;
    }

    let sessRx = Math.max(0, cur.rx - this.base.rx);
    let sessTx = Math.max(0, cur.tx - this.base.tx);
    let sessTot = sessRx + sessTx;

    this.menu.addMenuItem(new PopupMenu.PopupMenuItem(`Interface: ${this.iface}`));
    this.menu.addMenuItem(new PopupMenu.PopupMenuItem(`Session seit: ${baseStr}`));
    this.menu.addMenuItem(new PopupMenu.PopupMenuItem(`Session RX: ${fmtBytes(sessRx)}`));
    this.menu.addMenuItem(new PopupMenu.PopupMenuItem(`Session TX: ${fmtBytes(sessTx)}`));
    this.menu.addMenuItem(new PopupMenu.PopupMenuItem(`Session Total: ${fmtBytes(sessTot)}`));
    this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
    this.menu.addMenuItem(new PopupMenu.PopupMenuItem(`(Rechtsklick -> Reset)`));

    this.menu.toggle();
  }

  reDetectIface() {
    this.iface = getDefaultIface();
    this._applet_context_menu.removeAll();
    this._applet_context_menu.addAction(`Reset Session (${this.iface})`, () => this.resetSession());
    this._applet_context_menu.addAction(`Interface neu erkennen`, () => this.reDetectIface());
    this.resetSession(true);
  }

  resetSession(silent=false) {
    let cur = readIfaceBytes(this.iface);
    if (!cur) return;
    this.base = cur;
    this.baseEpoch = Math.floor(Date.now() / 1000);
    this.last = cur;
    this.lastTs = Date.now();
    this.saveState();
    if (!silent) this.tick();
  }

  loadState() {
    let txt = readText(this.cacheFile);
    if (!txt) return;
    try {
      let s = JSON.parse(txt);
      if (s && s.iface === this.iface && s.base && Number.isFinite(s.base.rx) && Number.isFinite(s.base.tx)) {
        this.base = s.base;
        this.baseEpoch = s.baseEpoch || null;
      }
    } catch (e) {}
  }

  saveState() {
    try {
      let s = { iface: this.iface, base: this.base, baseEpoch: this.baseEpoch };
      GLib.file_set_contents(this.cacheFile, JSON.stringify(s));
    } catch (e) {}
  }

  tick() {
    let cur = readIfaceBytes(this.iface);
    let now = Date.now();
    if (!cur) {
      this.set_applet_label(`↓ ? ↑ ?`);
      return true;
    }

    if (!this.last) {
      this.last = cur;
      this.lastTs = now;
      return true;
    }

    let dt = Math.max(0.5, (now - this.lastTs) / 1000.0);
    let drx = Math.max(0, cur.rx - this.last.rx);
    let dtx = Math.max(0, cur.tx - this.last.tx);

    let downBps = drx / dt;
    let upBps = dtx / dt;

    // Panel: nur Live-Speed (kompakt), Session steht im Klick-Menü + Tooltip
    this.set_applet_label(`↓ ${fmtBitsPerSec(downBps)}  ↑ ${fmtBitsPerSec(upBps)}`);

    if (this.base) {
      let sessRx = Math.max(0, cur.rx - this.base.rx);
      let sessTx = Math.max(0, cur.tx - this.base.tx);
      let sessTot = sessRx + sessTx;
      let baseStr = this.baseEpoch ? GLib.DateTime.new_from_unix_local(this.baseEpoch).format("%Y-%m-%d %H:%M:%S") : "n/a";
      this.set_applet_tooltip(
        `Interface: ${this.iface}\n` +
        `Session seit: ${baseStr}\n` +
        `Session RX: ${fmtBytes(sessRx)}\n` +
        `Session TX: ${fmtBytes(sessTx)}\n` +
        `Session Total: ${fmtBytes(sessTot)}`
      );
    }

    this.last = cur;
    this.lastTs = now;
    return true;
  }

  on_applet_removed_from_panel() {
    if (this._timer) Mainloop.source_remove(this._timer);
  }
}

function main(metadata, orientation, panelHeight, instanceId) {
  return new NetStopwatch(metadata, orientation, panelHeight, instanceId);
}
